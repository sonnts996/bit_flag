part of '../bit_flag.dart';

@immutable
mixin class BitFlag implements IBitFlag {
  /// Create a [BitFlag] with [value].
  /// The value can be shifted left if the [bitOffset] is not 0.
  const factory BitFlag(int value, {int bitOffset}) = _BitFlag;

  /// Create a [BitFlag] with a [value] as binary.
  /// The [value] is a numbers that only accept 0 and 1.
  ///
  /// Example:
  ///
  /// - If you want to create a flag with the value that is 0b0010, let's use BitFlag.binary(0010)
  const factory BitFlag.binary(String bin) = _BitFlagBinary;

  /// Create a [BitFlag] with a value that is generated by 1bit*[width] and shift left with [position]
  const factory BitFlag.at(int position, [int width]) = _BitFlagWithPosition;

  /// Create a [ZeroBitFlag] with the [mask]
  const factory BitFlag.zeroAt(IBitFlag mask) = _ZeroBitFlag;

  ///  Create a [ZeroBitFlag] with the [mask]'s value.
  const factory BitFlag.zeroAtValue(int value) = _ZeroAtValueBitFlag;

  @override
  int get value => 0;

  @override
  BitFlag flip() => BitFlags.flip(this);

  @override
  BitFlag extract(IBitFlag mask, {bool trimRight = false}) =>
      BitFlags.extract(this, mask, trimRight: trimRight);

  @override
  IBitFlag toggle(IBitFlag mask) => BitFlags.toggle(this, mask);

  @override
  BitFlag operator |(covariant IBitFlag other) => BitFlags.or(this, other);

  @override
  BitFlag operator &(covariant IBitFlag other) => BitFlags.and(this, other);

  @override
  BitFlag operator ^(covariant IBitFlag other) => BitFlags.xor(this, other);

  @override
  BitFlag operator <<(int other) => BitFlags.shiftLeft(this, other);

  @override
  BitFlag operator >>(int other) => BitFlags.shiftRight(this, other);

  @override
  bool hasFlag(IBitFlag flag) => BitFlags.hasFlag(this, flag);

  @override
  String toRadixString(int radix, [int width = 0]) =>
      BitFlags.toRadixString(this, radix, width);

  @override
  String toBinaryString([int? width]) {
    final bitLength = width ?? value.bitLength;
    return toRadixString(2, bitLength);
  }

  @override
  bool operator ==(Object other) {
    if (other is! IBitFlag) return false;
    return BitFlags.equals(this, other);
  }

  @override
  int get hashCode => value.hashCode;

  @override
  String toString() => switch (this) {
        ZeroBitFlag p1 => 'BitFlag($valueâ”†${p1.mask.value})',
        _ => 'BitFlag($value)',
      };
}

// ignore: missing_override_of_must_be_overridden
mixin _BitInternal on BitFlag {}

@immutable
// ignore: missing_override_of_must_be_overridden
class _BitFlag with BitFlag, _BitInternal {
  const _BitFlag(int value, {int bitOffset = 0})
      : assert(bitOffset >= 0),
        value = value << bitOffset;

  @override
  final int value;
}

@immutable
// ignore: missing_override_of_must_be_overridden
class _BitFlagWithPosition with BitFlag, _BitInternal {
  const _BitFlagWithPosition(this.position, [this.width = 1])
      : assert(position >= 0),
        assert(width >= 0);

  final int position;
  final int width;

  int get _binFlag => pow(2, width).toInt() - 1;

  @override
  int get value => _binFlag << position;
}

@immutable
// ignore: missing_override_of_must_be_overridden
class _BitFlagBinary with BitFlag, _BitInternal {
  const _BitFlagBinary(this.bin);

  final String bin;

  @override
  int get value => int.parse(bin.replaceAll(RegExp('[^0-1]'), ''), radix: 2);
}

@immutable
// ignore: missing_override_of_must_be_overridden
class _ZeroBitFlag extends ZeroBitFlag with BitFlag, _BitInternal {
  const _ZeroBitFlag(this.mask);

  @override
  final IBitFlag mask;
}

@immutable
// ignore: missing_override_of_must_be_overridden
class _ZeroAtValueBitFlag extends ZeroBitFlag with BitFlag, _BitInternal {
  const _ZeroAtValueBitFlag(this._maskValue);

  final int _maskValue;

  @override
  IBitFlag get mask => BitFlag(_maskValue);
}
